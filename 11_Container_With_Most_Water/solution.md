## 算法1 时间复杂度O(n^2)

- MaxV = Max(min{s, e} * (ie - is) | s = 0..n, e = s+1..n )

- s为起点，e为终点。is为起点的索引，ie为终点的索引

- 目标MaxV可以通过遍历所有情况，找出。

## 算法2 时间复杂度O(n)

- 分析公式 V = min(s, e) * (ie - is)

- 公式中(ie - is)的值只有可能为(1, 2, 3...n-1) , 0没有价值，作为退出条件。

- 考虑(ie - is)等于n-1的情况，此时V=min(s, e) * (n-1)

- 假设height[s] > height[e]，min(s, e-1) * (n-2) < min(s, e) * (n - 1)

- 同样height[s] < height[e], min(s+1, e) * (n-2) < min(s, e) * (n - 1)

- 通过数据归纳法可以证明在所有情况下都符合此等式。

- 那么我们从(ie - is) = n-1开始。每次将小的值的索引像中心滑动。则只需要在n的时间复杂度遍历所有ie-is的值就可以找到答案
